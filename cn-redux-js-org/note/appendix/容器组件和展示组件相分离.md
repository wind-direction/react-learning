# [容器组件和展示组件相分离](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0)

在写React应用的时候，我发现了一个及其有用的简单模式。如果你已经写了一段时间的React，你可能已经发现它。
[这篇文章](https://medium.com/@learnreact/container-components-c0e67432e005) 已经解释了很好了。但我还
想再增加一些观点。

如果你把组件分成两种类型你会发现你的组件更容易复用。我把它们叫做**容器型**和**展示型**组件。但同时我也听
说过*Fat*和*Skinny*，*Smart*和*Dumb*,*Stateful*和*Pure*，*Screens*和*Components*等等。这些说法并不完全
一样，但是核心思想是一致的。

我的**展示型**组件：

- 只关心事物看起来的是什么样的。
- 可能同时包含有展示型的组件和容器型组件，此外通常会有一些DOM标签和自有样式。
- 通常通过*this.props.children*来控制。
- 不依赖APP的其他部分，比如说Flux 的action 和 store。
- 不会特别指明数据是如何被加载的和如何发生突变的。
- 只会通过props 来接收数据和回调。
- 几乎不会有他们自己的状态（如果有，更可能是UI的状态而非数据）。
- 被编码成[函数式组件](https://facebook.github.io/react/blog/2015/10/07/react-v0.14.html#stateless-functional-components)。除非他们需要状态，生命周期的钩子，或者性能优化。
- 例如：*Page*， *Sidebar*，*Story*，*UserInfo*，*List*。

我的**容器型**组件：

- 只关心事物如何工作。
- 会包含展示型组件和容器型组件。但是通常不会包含任何DOM标签除了一些包装式的`div`。也从来不会有任何样式。
- 会为展示型组件或者其他容器型组件提供数据和行为。
- 会调用Flux的action并将他们以回调的方式提供给展示型组件。
- 通常情况下是有状态的，更倾向于以数据源的方式提供服务。
- 通常由[高阶组件](https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750)产生。
  比如React Redux 的`connect()`， Relay中的`createContainer()`，或者是Flux Utils中的`Container.create()`。并不推荐直接
  手写编码实现。
- 例如：*UserPage*，*FollowersSidebar*，*StoryContainer*，*FollowedUserList*。

我把他们放到不同的目录中，这样看起来会更清晰些。

## 这样做的好处

- 更好的分散注意力。通过这种方式编写组件可以更好的理解你的APP和你的UI。
- 更好的复用。你可以在完全不同的state源的情况下使用同样的展示型组件，而且可以将它们组装到不同的容器组件中，从而达到更高
  级别的复用级别。
- 展示型组件本质上是APP的"外在"。你可以将他们放到一个单独的页面中，让设计师在不用触碰APP的底层逻辑情况下对UI进行修改。你
  可以在这个页面中进行屏幕快照的回归测试。
- 这会强迫你挑出"布局组件"比如说*Sidebar*，*Page*，*ContextMenu*，并在容器型组件中使用`this.props.children`代替重复标签
  和布局。

记住，**组件不必包含DOM**。他们只需要提供不同UI之间的构造边界。

记住这个有利条件。

## 何时引入容器？

我建议首先只通过展示型组件来构建APP。最终你会意识到你传递了太多`props`给中间层的组件。当你注意到有些组件不会使用他们接收
到的`props`而仅仅只是将他们传递下去时，以及每当子组件需要更多的数据时，你就不得不重写所有中间的组件。这个时候就需要引入
一些容器性组件。这样的话，你就可以将数据和行为`props`传递给叶子组件，而不用加重组件树中那些无关组件的负担。

这是一个持续的重构过程，所以不要试图第一次就成功。当你试过几次这种模式，你就会凭直觉找出何时应该提取容器。就好像你知道什
么时候应该抽象出一个方法。我的这篇[free Redux Egghead series](https://egghead.io/courses/getting-started-with-redux)文章
可能对你有所帮助。

## 其他的二分法

理解展示型组件和容器的区别不是技术性的这一点很重要。只是区别于他俩的目的。

相较之下，这里有一些相关（但不相同！）的技术差异：

- **有状态的和无状态的**。部分组件会使用React的`setState()`的方法有些不会。将容器组件调整成有状态的而将展示组件调整成无状
  态的，这并不是一个硬性的规则。展示组件也可以是有状态的，容器组件也可以是无状态的。
- **类和函数**。从React 0.14版本开始，组件可以声明成类也可以声明成函数。函数式组件更容易定义，但是它们缺少目前仅适用于类
  组件的某些功能。这些限制可能会在将来去掉，但是现在他们依然存在。由于函数式组件更容易理解，我建议你，在不需要state，生命
  周期、钩子或者不需要考虑性能优化的情况下尽量使用函数式组件。并尽量在类式组件中使用上述这些功能。
- **纯粹和不纯粹**。人们将那些在给定同样的props和state的情况下，返回相同的结果的组件称之为是纯粹的。纯粹组件可以被定义成
  函数式组件也可以被定义成类式组件，且既可以是有状态的也可以是无状态的。纯粹组件另外一个重要的方面就是他们并不依赖state或
  者props的深层突变（注：原文 deep mutations ），这样一来，他们的渲染性能是可以在`shouldComponentUpdate()`钩子中通过一个
  浅比较从而得到优化。目前只有类式组件可以定义`shouldComponentUpdate()`，但是在将来这种局面也许会改变。

展示组件和容器组件都可以被归类到这些情况中。在我的经验里，展示组件更倾向于无状态的纯函数组件，容器组件倾向于有状态的纯类
式组件。但这并不是一条规则而只是一条总结经验，我也见过在特定情境下恰恰相反的情况也是合理的。

不要死板硬套的区分展示组件和容器组件。有些时候他并没有什么关系，或者很难界定两者的边界。如果你不是很确定一个组件到底应该
是展示组件还是容器组件，这可能意味着现在决定还为时尚早。

